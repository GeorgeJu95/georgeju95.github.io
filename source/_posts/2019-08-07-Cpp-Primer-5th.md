---
title: C++ Primer（5th）阅读总结
date: 2019-08-07 7:47:36
categories: 
toc: true
tags: [C++]
---

### Unit 1 开始

* 标准库定义了四个IO对象：istream对象: cin；ostream对象: cout、cerr(输出警告和错误消息)、clog(输出程序运行时的一般性信息)。
* **操纵符** endl：结束单前行，并将与设备关联的缓冲区中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入输出流，而不是仅停留在内存中等待写入流。程序员常常在调试时添加打印语句。这类语句应该保证“一直”刷新流。否则，如果程序崩溃，输出可能还留在缓冲区中，从而导致关于程序崩溃位置的错误推断。

# Part 1. C++基础
<!-- more -->
### Unit 2 变量和基本类型

* 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来代替。

* ``C++11`` 列表初始化(花括号)，初始值存在丢失精度风险的话，编译器将报错。

* 全局变量被初始化为0，定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。类的对象如果没有显示地初始化，则其值由类确定。

```c++
  extern int i;  //声明i而非定义i
  extern double pi = 3.1416;   //定义
```

* 变量能且只能被定义一次，但是可以被多次声明。

* ``C++11`` 中新增了一种引用：**右值引用**(rvalue reference)，将在13.6.1中详细介绍，这种引用主要用于内置类。严格来说，术语“引用”一般指**左值引用**(lvalue reference)。

```c++
  int ival = 1024;
  int &refVal = ival;  //refVal指向ival(是ival的另一个名字)
  int &refVal2;  //报错，引用必须被初始化。
```

* 定义引用，程序把引用和它的初始值**绑定**在一起，无法令引用重新绑定另一个对象，因此**引用必须初始化**。

* **引用并非对象**，所以不能定义引用的引用。引用只能绑定在对象上，而不能与字面值或者某个表达式的计算结果绑定在一起(除了2.4.1和15.2.3将介绍的两种情况)

* **指针本身就是一个对象**，允许对指针赋值和拷贝，而且在其生命周期内可以先后指向几个不同的对象。**指针无须在定义时赋初值**。

* ``C++11`` 空指针nullptr，是一种特殊类型的字面值，它可以被转换成任意其他的指针类型。

* 指针和引用都能提供对其他对象的间接访问，但是注意其以上不同之处。

* Void* 指针可以存放任意对象的地址，但不能直接操作其所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。

* **const对象**一旦创建后其值就不能再改变，所以const对象必须初始化。 

* 程序员常把**“对const的引用”**简称为**“常量引用”**(一种习惯叫法)，与普通引用不同，对常量的引用不能被用作修改它所绑定的对象。

* 对const的引用可以引用一个并非const的对象

```c++
int i = 42;
int &r1 = i;
const int &r2 = i;  // r2也绑定i，但是不允许通过r2修改i的值
r1 = 0;
r2 = 0;  // 错误，r2是一个常量引用
```

* 类似于常量引用，**指向常量的指针**(可以不初始化)不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针
* 允许令一个指向常量的指针指向一个非常量对象。

```c++
const double pi = 3.14;
double *ptr = &pi;  // 错误，ptr只是一个普通指针
const double *cptr = &pi;
*cptr = 42;  // 错误，不能给*cptr赋值
double dval = 3.14;
cptr = &dval;
```

* 所谓指向常量的指针或引用，仅仅要求不能通过它们改变对象的值，而没有规定那个对象的值不能通过其他途径改变。
* 因为指针本身即对象，允许把指针本身定位常量，即**const指针**，也就是**常量指针**(必须初始化)，一旦初始化完成，它的值(也就是存放在指针中的地址)就不能改变了。不变的是指针本身的值，而不是指向的那个值。

```c++
int errNumb = 0;
int *const curErr = &errNumb;  // curErr将一直指向errNumb
const double pi = 3.14159；
const double *const pip = &pi;  // pip是一个指向常量对象的常量指针
```

* **顶层const**表示指针本身是个常量，**底层const**表示指针所指的对象是一个常量。可以扩展到一般，指针比较特殊，既可以是顶层const也可以是底层const。用于声明引用的const都是底层const。
* 当执行对象的拷贝操作时，常量是顶层const还是底层const影响明显。其中，顶层const不受什么影响；**底层const的限制却不能忽视**。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不行。

```c++
int i = 0;
int *const p1 = &i;  // 不能改变p1的值，顶层const
const int ci = 42;  // 不能改变ci的值，顶层const
const int *p2 = &ci;  // 允许改p2的值(这是指向常量的指针)，底层const
const int *const p3 = p2;  // 靠右，顶层；靠左，底层
const int &r = ci;  // 用于声明引用的const都是底层const
i = ci;  // 正确，ci是一个顶层，无影响
p2 = p3;  // 正确，指向对象类型相同，p3顶层部分不影响
int *p = p3;  // 错误，p3包含底层const，p没有
p2 = p3;  // 正确，都是底层
p2 = &i;  // 正确，int* 可以转换成 const int*
int &r = ci;  // 错误，普通的int& 不能绑定到int常量
const int &r2 = i;  // 正确，const int& 可以绑定到一个普通int
```

* ``C++11`` 声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化。
* 算数类型、引用、指针属于字面值类型。自定义类、IO库、string类型不属于，也就不能被定义成constexpr。
* 必须明确一点，在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指对象无关。

```c++
const int *p = nullptr;  // p是一个指向整型常量的指针
constexpr int *q = nullptr;  // q是一个指向整数的常量指针
```

* ``C++11`` 别名声明 **using** SI = Sales_item;（类似于传统typedef）。**auto**类型说明符，让编译器通过初始值来推算变量的类型。显然，auto定义的变量必须有初始值。**decltype**类型说明符，选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。

```c++
decltype(f()) sum = x;  // sum的类型就是函数f的返回类型
const int ci = 0, &cj = ci;
decltype(ci) x = 0;  // x的类型是const int
decltype(cj) y = x;  // y是const int&，y绑定到x
decltype(cj) z;  // 错误，z是一个引用，必须初始化

// 表达式内容是解引用操作，得到的是引用类型
int i = 42, *p = &i;
decltype(*p) c;  // 错误，c是int&，必须初始化
// 表达式如果是加上了括号的变量，结果将是引用
decltype((i)) d;  // 错误，d是int &，必须初始化。双层括号结果永远是引用。
decltype(i) e;  // 正确，e是一个(未初始化)的int
```

* 预处理功能： #include；头文件保护符，依赖于预处理变量，#ifndef   #define   #endif

### Unit 3 字符串、向量和数组

* 为了与C兼容，**字符串常量与string类型不是同一种类型**

* 读取操作，string对象会自动忽略开头处的空白（即空格符、换行符、制表符等）并从第一个真正的字符开始读起，直到遇见下一处空白为止。

* getline(cin, s); 不忽略开头的空白字符，遇见换行符为止（不把换行符存入s）。

* 字符串常量的加法是非法的，string变量与字符串常量的加法是合法的。

* 范围for语句，该语句体不应改变其所遍历序列的大小。for(auto c : str) cout << c << endl;

* 类模板vector初始化，成为类类型：

```c++
vector<T> v1;  // 默认初始化，类型为T的空vector
vector<T> v2(v1);
vector<T> v3(n, val); // n个元素，每个都是val
vector<T> v1(n);  // n个重复执行了值初始化的对象
vector<T> v1(a, b, c...);
```

* 迭代器：一种检查容器内元素并遍历元素的数据类型，标准库为每种标准容器定义了一种迭代器类型。若为::const_iterator iter;则该类型只能用于读取容器内元素，但不能改变其值。如果容器对象是一个常量，只能使用const_iterater，不是常量，两种类型的迭代器都可以。``C++11`` 引入了两个新函数，**cbegin和cend**，也返回第一个和最后一个元素的下一个位置，但是无论容器对象本身是否是常量，返回值都是const_iterater。
```c++
vector<T> v1(n);
vector<T>::iterator iter;
iter = v1.begin();
iter = v1.end();  //尾后迭代器，返回指向容器“尾元素的下一位置”
```

* 任何改变vector长度的操作都会使已存在的迭代器失效。

* C++的 bitset 在 bitset 头文件中，它是一种类似数组的结构，它的每一个元素只能是０或１，每个元素仅用１bit空间。详细见该博客[C++ bitset 用法](https://www.cnblogs.com/magisk/p/8809922.html)，注意foo[2]，foo.flip(2)，这种下标是从右边数起 (也是从0开始)。

* 只有追求高性能时，才用数组。一般情况推荐用vector

```c++
int a[] = {0, 1, 2};
string b[2] = {"hi", "bye"};
char c[] = "c++";  // c[3] = '\0';
int *prts[10]; // 指针数组，该数组含有10个整型指针
int &refs[10] = /* ? */     //错误，不存在引用的数组
int (*Parray)[10] = &arr;   //数组指针，指向一个含有10个整数的数组
int (&Parray)[10] = arr;    //数组引用，引用一个含有10个整数的数组
int *beg = begin(arr);  // C++11引入，与容器的两个同名函数功能类似，但是数组不是类类型，因此这两个函数不是成员函数
int *last = end(arr);   // 指向arr尾元素的下一位置的指针

int ia[3][4];
int (*p)[4] = ia;  // p指向含有4个整数的数组
p = &ia[2];   // p指向ia的尾元素，也就是最后一行
// &*(ia+2)指向行元素，ia[2]、*(ia+2)、&ia[2][0]，指向最后一行的首元素地址，即指向列元素。
```

* C++允许计算数组或对象时超出末端的地址，但不允许对其解引用。
* 数组的名字其实是一个指向数组首元素的指针，对数组执行下标运算其实是对指向数组元素的指针执行下标运算。虽然标准库类型string和vector也能执行下标运算，但是数组与它们相比还是有所不同。标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求。
```c++
constexpr size_t rowCnt = 3, colCnt = 4;
int ia[rowCnt][colCnt];
for(size_t i=0; i!=rowCnt; ++i)
  for(size_t j=0; j!=colCnt; ++j) {
    ia[i][j] = i*colCnt + j;
  }
// 范围for处理ia这个二维数组，等价于上面的写法
size_t cnt = 0;
for(auto &row : ia)     // 范围for处理多维数组，除了最内层的循环变量外，其他所有的循环控制变量都应该是引用类型，这是为了避免数组被自动转成指针
  for(auto &col : row) {
    col = cnt;
    ++cnt;
  }
```

### Unit 4 表达式

* &&的短路特性（前面的不满足后面的不用判断），||的并流特性（前面的一旦满足，后面的不用看）
* 当一个对象被用作**右值**时，用的是对象的值（内容）；当对象被用作**左值**的时候，用的是对象的身份（在内存的位置）。需要右值的地方，可以用左值来代替，但是不能把右值当成左值（也就是位置）使用。当一个左值被当成右值时，实际使用的是它的内容（值）。
  * 赋值运算符需要一个(非常量)左值作为其左侧运算对象，得到的结果也仍然是一个左值。
  
  * 取地址符作用于一个左值运算对象，返回一个指针，这个指针是一个右值。
  
  * 内置解引用运算符，下标运算符、迭代器解引用运算符、string和vector的下标运算符的求值结果都是左值。
  
  * 内置类型和迭代器的递增递减作用于左值运算对象，其前置版本所得结果也是左值。
  
  * 如果表达式的求值结果是左值，decltype作用于该表达式（不是变量）得到一个引用类型。假如p是int *，因为解引用生成左值，所以decltype(※p)是int &；因为取地址符生成右值，所有decltype(&p)的结果是int ※※，也就是一个指向整形指针的指针。
* 递增和递减运算符：都必须作用于左值运算对象，**前置版本**将对象本身作为左值返回，**后置版本**则将对象原始值的副本作为右值返回。如无特殊必要(如果我们想要在一条复合表达式中既将变量加1或减1又能使用它原来的值，这时使用后置版本)，建议养成使用前置版本的习惯（开销更小，尤其是在复杂迭代器中）。
* 强制类型转换：（建议避免使用）

```c++
格式：cast-name<type>(expression)
static_cast  // 任何具有明确定义的类型转换，只要不包括底层const，都可以使用它。常用于替代由编译器隐式执行的类型转换。
const_cast   // 只能改变运算对象的底层const
reinterpret_cast // 通常为运算对象的位模式提供较低层次上的重新解释
dynamic_cast  // 支持运行时类型识别(19.2节 p730)
```

### Unit 5 语句

* Switch case，case标签必须是整型常量表达式
* 跳转语句：break、continue、goto(语法：goto *label*)
```c++
begin:
int sz = get_size();
if(sz <= 0) goto begin;
```

* 异常处理

  * **throw**表达式，异常检测部分使用throw表达式来表示它遇到了无法处理的问题。我们说throw**引发**了异常。
  * **try**语句块，异常处理部分使用try语句块处理异常。try语句块以关键字try开始，并以一个或多个**catch子句**结束。try语句块中代码抛出的异常通常会被某个catch子句处理。
  * 一套**异常类**，用于在throw表达式和相关的catch子句之间传递异常的具体信息。
  * 如果一段程序没有try语句块且发生了异常，系统会调用terminate函数并终止当前程序的进行。
  
```c++
if(item1.isbn() != item2.isbn())
	throw runtime_error("Data must refer to same ISBN")
cout << item1 + item2 << endl;
while(cin >> item1 >> item2) {
	try {
		// 执行添加两个Sales_ittem对象的代码
		// 如果添加失败，代码抛出一个runtime_error异常
	} catch (runtime_error) {
		// 提醒用户两个ISBN必须一致，询问是否重新输入
    cout << err.what()
      	 << "\nTry Again？Enter y or n" << endl;
    char c;
    cin >> c;
    if(!cin || c == 'n')
      break;
	}
}
```

### Unit 6. 函数

* **传引用参数**：使用引用避免拷贝、使用引用形参返回额外信息。当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。
* 尽量使用**常量引用**。这样这个参数不会改变；而且使用引用而非常量引用也会极大地限制函数所能接受的实参类型。
* 若形参是数组的引用，则编译器不会将数组参数化为指针，而是传递数组的引用本身。
* 确保不越界的方法：
  * 数组本身放置一个结束标记，如null
  * 传递指向数组第一个和最后一个元素的下个位置的指针
  * 将第二个形参定义为表示数组的大小

* 函数重载。调用这些函数时，编译器根据传递的实参类型推断想要的是哪个函数。对于重载函数来说，应该在形参数量或类型上有所不同。不允许两个函数除了返回类型外其他所有的要素都相同。

* 顶层const不影响传入函数的对象，即一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来。如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是**底层**的。

* **内联函数**：将它在每个调用点上”内联地“展开。在函数的返回类型前面加上关键字**inline**。一般内联机制使用于小的只有几行且经常被调用的函数，不支持递归函数。

* constexpr函数，指能用于常量表达式的函数：函数的返回值类型及所有形参的类型都是字面值类型，而且函数体中必须有且只有一条return语句。一个constexpr函数被隐式地声明成内联函数。

* 内联函数和constexpr函数通常定义在头文件中。不同于一般函数，因为编译器必须看到定义才能展开。

* 调试帮助：

  * 预处理宏assert(expr)：定义在cassert头文件中。对expr求值，表达式为0，assert输出信息并终止程序；为真，assert什么也不做。

  * NDEBUG预处理变量，如果定义了它，则assert什么也不做。可以用其编写自己的条件测试代码，如果NDEBUG未定义，将执行#ifndef和#endif之间的代码；如果定义了，这些代码将会被忽略掉。

* 函数指针，指向函数。
```c++
bool lengthCompare(const string &, const string &);
bool (*pf)lengthCompare(const string &, const string &); //未初始化的函数指针，括号不能少
pf = lengthCompare; pf = &lengthCompare; // 等价的赋值语句
bool b1 = pf("hello", "goodbye");
bool b2 = (*pf)("hello", "goodbye"); // 等价的调用，无需提前解引用。
```

* 重载函数的指针，编译器通过指针类型决定选用哪个函数。
* `C++11`含有可变形参的函数。了解一个**initializer_list**，标准类，表示的是一组花括号包围的类型相同的对象，对象之间以逗号隔开（某种特定类型的值的数组）。如果实参类型不同，可以编写一种特殊的函数，也就是所谓的**可变参数模板**。

第7章进入类，由于暂时不想深究C++了(先学Java 233)，所以先告一段落。（暑假看过类这一章，但是忘的差不多，所以如果以后要学C++，就出此处出发~~）