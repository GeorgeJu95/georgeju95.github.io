---
title: 视觉SLAM第三讲——初识SLAM
date: 2019-07-01 14:30:00
categories: 读书笔记
toc: true
tags: [视觉SLAM十四讲]

---

## 基础概念
**传感器**：

- 携带于机器人本体上，如：激光传感器、相机、轮式编码器、IMU（惯性测量单元）等。
- 安装于环境中，如：导轨、二维码标志、无线电定位设备等。
<!-- more -->


**单目相机(Monocular)** ：

- 照片（场景在相机的成像平面上留下的一个投影）
- 二维形式反映三维世界，丢失了场景的**深度（距离）** 维度。
- 移动相机改变视角，可以估计相机运动和场景结构
  1. 相机右移，图像里的东西左移。
  2. 近处的物体移动快，远处的物体运动缓慢。
  3. 形成视差，通过视差可以定量判断物体距离（**相对距离**）。
- 尺度不确定性
  1. 单目SLAM估计的轨迹和地图与实际的轨迹和地图相差一个因子，也就是所谓**尺度**。
  2. 单目SLAM无法仅凭图像确定这个真实尺度。



**双目相机 (Stereo)**：

- 克服单目相机无法知道距离的缺点，消除尺度不确定性。
- 两个单目相机组成，之间的距离称为**基线**，基线距离越大，能够测量到的就越远。
- 缺点：
  1. 配置与标定均较为复杂，深度量程和精度受双目的基线和分辨率所限。
  2. **视差的计算非常消耗计算资源**，需要使用GPU和FPGA设备加速后，才能实时输出整张图像的距离信息。因此现有条件下**计算量是双目的主要问题之一**。



**深度相机(RGB-D)** :

- 通过红外结构光或Time-Of-Flight(ToF)原理测距（**物理测量**）
- 缺点： 测量范围窄、噪声大、视野小、易受日光干扰、无法测透射材质等。主要用于室内，室外则较难应用。 





## 经典的SLAM框架：

![alt](/assets/blogImg/slam.png)

**视觉里程计(Visual Odmetry)**:   <u>前端和CV研究更相关，如图像的特征提取与匹配</u>

- 通关相邻帧间的图像估计相机运动，并恢复场景的空间结构。
  <u>只计算相邻时刻的运动，和再往前的过去的信息没有关联</u>
- **累积漂移**(只计算相邻时刻运动的原因)：先前时刻的误差将会传递到下一时刻。<u>(后端优化、回环检测来解决)</u>



**后端优化**：~~如滤波与非线性优化算法~~

- 如何从带有噪声的数据中估计整个系统的状态，以及这个状态估计的不确定性有多大——**最大后验概率认证**(MAP)



**回环检测**：

- 解决位置估计随时间漂移的问题
- 判断图像间相似性



**建图**：

- 度量地图(Metric Map)： 稀疏 OR 稠密
- 拓扑地图(Topological Map)： 图(Graph)，强调节点间的连通性。

## SLAM问题的数学表达

**运动方程：$$ \vec x_k = f(\vec x_{k-1}, \vec u_k, \vec w_k) $$**

其中 $ \vec u_k $是运动传感器的读数, $ \vec w_k $是噪声，$ \vec x_k、\vec x_{k-1}$是机器人的两个时刻不同的位姿。

**观测方程：$$ \vec z_{k,j} = h(\vec y_j, \vec x_k, \vec v_{k,j}) $$**

其中 $ \vec y_j $是某个路标点, $ \vec v_{k,j} $是这次观测里的噪声。机器人在$ \vec x_k $位置看到某个路标点$ \vec y_j $产生了一个观测数据$ \vec z_{k,j} $。

**状态估计问题**：
这两个方程描述了最基本的SLAM问题。已知运动测量的读数$\vec u$，以及传感器的读数$\vec z$，如何<mark>求解定位问题($\vec x$)和建图问题($\vec y$)</mark>? 这时我们把SLAM问题建模成了一个状态估计问题：<u>如何通过有噪声的测量数据，估计内部的、隐藏着的状态变量？</u>

状态估计问题的求解：

- 两个方程的具体形式。<u>线性(Linear)/非线性(Non-Linear)系统</u>
- 噪声服从哪种分布。<u>高斯(Gaussian)/非高斯(Non-Gaussian)系统</u>

LG系统：<u>卡尔曼滤波器</u>(KF) ---> 无偏的最优估计
NLNG系统：<u>扩展的卡尔曼滤波器</u>(EKF)、<u>非线性优化</u> 两大类方法去求解。

时至今日，主流视觉SLAM使用以图优化为代表的优化技术进行状态估计。普遍认为优化技术已经明显优于滤波器技术，只要**计算资源允许，通常都偏向于使用优化方法**。




## 实践部分

* 学习cmake-make编译，cmake过程处理了工程文件之间的关系，而make过程实际调用了g++来编译程序。虽然这个过程多了调用cmake和make的步骤，但我们对项目的编译管理工作，从输入一串g++命令，变成了维护若干个比较直观的CmakeLists.txt文件，这将明显降低维护整个工程的难度。
* Linux中，库文件分成静态库(.a)和共享库(.so)两种，只要拿到了头文件和库文件，就可以调用这个库了。